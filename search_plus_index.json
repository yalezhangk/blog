{"./":{"url":"./","title":"介绍","keywords":"","body":"Welcome to yalezhang 's blog 😎 *本博客内容持续更新...精彩内容就快出来啦... 如需转载, 请注明出处 如果我的博客对你有帮助 , 那就帮我点个星星吧 🤣 Star 作者 🤣 个人主页 : Blog GitHub : https://github.com/yalezhangk email : yalezhang.china@gmail.com 感谢 🍀 感谢以下老哥们提供的宝贵意见与指正, 一起进步 lyonyang: https://lyonyang.github.io/blogs/ 博客向导 🍀 本博客由 Travis CI 自动构建 目录 : . ├── Python ├── Database ├── Algorithm ├── Git │ └── git ├── WebFramework │ ├── Django │ ├── Flask │ └── Tornado ├── Linux ├── Docker ├── Computer ├── Network │ └── TCP/IP └── Tools 博客搭建指南 : GitHub Pages&Gitbook&Travis CI持续构建博客 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"Summary 介绍 目录 Python Python基础 Database Mysql mysql基础 mysql45讲 Algorithm WebFramework Git Linux linux mac_os Docker Computer Network Tools "},"01-Python/":{"url":"01-Python/","title":"Python","keywords":"","body":"Python python相关博客记录 "},"01-Python/01-Python基础.html":{"url":"01-Python/01-Python基础.html","title":"Python基础","keywords":"","body":"[toc] 一、换行符 Unix 系统中：每行结尾只有 \"\"，即 \"\\n\"； Windows 系统中：每行结尾是 \"\"，即 \"\\r\\n\"； Mac 系统中：每行结尾是 \"\"，即 \"\\r\"。二、运算符(and/or) 1. and/or ==在python中：0、''、\"\"、[]、()、{}、None、False为假；其它任何东西都为真，注意' '、\" \"为真== ==and实例：从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。==>> 'a' and 'b' 'b' >> '' and 'b' '' >> ' a' and 'b' and 'c ' 'c ' ==or实例：从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值==。 ==and or 没有先后级别;or有短路现象，即如果为真，后面的不执行== >> 'a' or 'b' 'a' >> '' or 'b' 'b' >> '' or \"\" or () or {} {} == or短路现象 == >>>False and 1 or 2=>False or 2=>2 >>>1 or 2 and False=>1（1为真之后，后面就不会判断了，直接返回1） >>>(1 or 2 ) and False=>1 and False=>False 2.3 算术运算符 有：==+(加) 、-(减)、(乘)、/(除)、%(取模、取余)、**(幂)、//(取整除)== 运算符执行顺序* 一般按照从左到右的顺序正常执行。 ==2 == 2 > 1 的结果却为True==,这涉及到Python中的==链式对比==，上式等价于 2 == 2 and 2 > 1 ,其结果为True 三、循环 break用来结束整个循环，continue用来结束本次循环，紧接着执行下一次循环 break/continue只能用在循环中，除此以外不能单独使用。break/continue在嵌套循环中，只对最近的一层循环起作用四、函数及变量 缺省参数，参数没传入的话，使用默认值 ==带有默认值的参数一定要位于参数列表的最后面==def printinfo( name, age = 35 ): # 打印任何传入的字符串 print \"Name: \", name print \"Age \", age # 调用printinfo函数 printinfo(name=\"miki\" ) printinfo( age=9,name=\"miki\" ) 函数内部变量定义并且赋值，该变量为局部变量; 在函数外部定义的变量，为全局变量； 函数内部使用变量名，局部变量名和全局变量名同名，优先使用局部变量; 在函数内部如果想要使用全局变量，使用global关键字声明; ==全局变量在函数内部未声明的情况下，只能使用，不可修改值== ==函数参数传递：可变参数是引用传递，不可变参数是值传递==五、字符串str 字符串本质是字符序列。Python的字符串是不可修改的。无法对原字符串进行修改，但是可以将字符串的一部分赋值到新字符串，来达到相同的修改效果。 只有+和*运算 提取用[],下标 切片[start:end:step], 左闭右开，下标 字符串反转[::-1]5.1 字符串操作 len(str),获取长度 ==str.split('分隔符', 分割次数) 分割成若干字串组成的列表，默认全分割== ==' '.join(li1), 以空格将列表组成为str， 方法要求列表中的元素为字符串才可操作== str.find('a'), str.rfind('a')查找字串，第一次、最后一次出现的位置，返回位置（下标），若无，返回-1 ==str.startswith('a')== 以某字符开头，返回True或False ==str.endswith('b')以某字符结尾== str.replace('a','b',2)替换 ==str.splitlines()==, 返回str中的行列表，在行边界处中断。 通常用于有换行符\\n的切割，返回str列表 ``` str1 = '1,2,3,4' li1 = str1.split(',', 2)['1','2','3,4'] 此方法要求列表中的元素为字符串才可操作 li2 = ['1','2','3','4'] s1 = '-'.join(li2)'1-2-3-4' s = \"abadeag\" s1 = s.replace(\"a\", \"1\",2) print(s1) 1b1deag 7. ==str.strip()：默认删除两侧空格== 8. ==str.strip('字符')：删除首尾两侧字符== 8. str.count('a'),统计某字符出现的次数 ## 5.2 str格式化 1. ==py2.6引入的：str.format()== 2. ==f或F表达式，py3.6引入的格式化字符串的方法== name = '张可' print('He is {}'.format(name)) He is 张可 格式化数字 print(\"{:.2f}\".format(3.1415926)); 3.14 name = '张可' age = 12 a = f'He is {name}, age is {age}' He is 张可, age is 12 # 六、列表 list 1. 列表非常适合利用顺序和位置定义某一个元素，尤其是当元素的顺序或内容经常发生改变的时候.列表可修改、添加、删除、覆盖 ## 1. 列表操作 1. list.append('a'),尾部追加元素 2. extend()合并列表 3. ==list1.extend(list2),等价于list1 += list2, 将lis2中的元素依次添加到list1中== 4. list.insert(1,'a')，指定位置前插入元素 5. python删除方法del，del list[0], 删除list第一个元素 6. ==list.remove('a'), 删除a元素== 7. list.pop(1),输出第1位置的元素，并将之删除 8. list.index('a'), 返回a元素的下标 9. in 判断某元素是否存在 10. ==str.join(list)，将列表转化为字符串==，==list中的元素必须是str型的== list = ['aaa', 'bbb', 'ccc'] str1 = ','.join(list) str2 = ';'.join(list) --要求list中的元素必须是str-- print(str1) print(str2) aaa,bbb,ccc aaa;bbb;ccc li = [1,2,3] 会报错，无法转换 str_error = ''.join(li) 11. ==list.sort()，对原列表升序排序; sorted(list),则会生成一个新列表，升序== 12. ==sorted(元素，key, reverse),产生一个新列表== fruits = ['grape', 'raspberry', 'apple', 'banana'] sorted(fruits, key=len, reverse=True) ['raspberry', 'banana', 'grape', 'apple'] fruits ['grape', 'raspberry', 'apple', 'banana'] 12. len(list), 返回列表长度 13. ==两个list求交集、并集、差集：可以将list转为set,效率更高==（注意list中不存在重复元素才可用set中转） list1 = [1,2,3,4] list2 = [1,2,3,5] 交集 retA = [i for i in list1 if i in list2] retA = list(set(list1).intersection(ste(list2))) 等价于 retA = list(set(list1) & set(list2)) 并集 retB = list(set(list1).union(set(list2))) 等价于 retB = list(set(list1) | set(list2)) 求差集，在list1中但不在list2中 retC = list(set(list1).difference(set(list2))) 等价于 retC = list(set(list1) - set(list2)) # 七、元组Tuple() 1. 元组元素不可改变，占用空间小 2. python中不允许修改元组的数据，包括不能删除其中的元素。 3. 访问元组中的元素,通过下标：tuple[0] tup1 = ('physics', 'chemistry', 1997, 2000) tup2 = (1, 2, 3, 4, 5, 6, 7 ) print \"tup1[0]: \", tup1[0] print \"tup2[1:5]: \", tup2[1:5] # 八、字典dict{} ## 8.1 字典操作 ==字典的k必须是可hash的，即键必须是不可变类型的(str、int、tuple、bool)== 1. ==字典推导式 d = {key: value for (key, value) in dict.items()}== 1. ==dict1.update(dict2) 更新dict1(dict2中的元素更新到dict1中)，以dict2为准== dict1 = {'name': 'zk', 'age': 18} dict2 = {'name': 'zk', 'age': 19} dict1.update(dict2) print(dict1) {'name': 'zk', 'age': 19} 2. dict.keys()获取所有键 > ['a', 'b', 'c'] 3. dict.values()获取所有值 > [1,2,3] 4. dict.items()获取所有键值对 > [('a',1),('b',2),('c',3)] 5. len(dict1) 返回字典的长度 ## 8.2 字典的底层实现 ### 1. 概述 1. py3.7以前dict是无序的，3.7以后dict是有序的 2. ==py字典是通过散列表(哈希表)实现的==，即哈希数组，即字典是一个数组，但数组的索引是键(key)经过哈希函数处理后得到的散列值。 3. 由于不同的键可能具有相同的哈希值，即哈希冲突。py中建立哈希表的具体过程如下： - 数据添加：==把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里==。 - 数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。 4. ==哈希函数就是一个映射==，因此==怎么设计合理的哈希函数==很重要，==即key哈希后形成映射关系，本质上是一个多对一的映射,可能几个key的哈希值一样,就形成了哈希冲突==。 5. 新字典的2点变化： - ==字典占用的内存变小了==。旧字典为了减少hash冲突的概率，总会预留大于1/3的容量的hash位置，现在则不必预留。 - ==字典有序了==。 ### 2. 解决哈希冲突 > **1. 开放寻址法** > 1. ==py2使用开放寻址法解决冲突==，CPython使用==伪随机探测的散列表==作为字典的底层数据结构。 > 2. 开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个==探测函数==计算出下一个候选位置，如果下一个获选位置还是有冲突，那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。 > 3. 开放地址的意思是除了哈希函数得出的地址可用，当出现冲突的时候其他的地址也一样可用，常见的开放地址思想的方法有==线性探测再散列，二次探测再散列等==，这些方法都是在第一选择被占用的情况下的解决方法。 > **2. 链表法** > 1. HashMap数组的==每一个元素不仅是一个数组对象，还是一个链表的头节点==。每一个Entry对象通过next指针指向他的下一个Entry节点，==当新来的映射冲突时，只需插入到对应的链表中即可==。 > **3. 再哈希法** > 1. 这个方法是按顺序==规定多个哈希函数，每次查询的时候按顺序调用哈希函数，调用到第一个为空的时候返回不存在，调用到此键的时候返回其值==。 > **4. 公共溢出区** > 1. 其基本思想是：所有关键字和基本表中关键字为相同哈希值的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。 > **5. 装填因子α** > 1. 一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。哈希表的装填因子定义为表中填入的记录数和哈希表长度的比值，也就是标志着哈希表的装满程度。 > 2. 直观看来，==α越小，发生冲突的可能性就越小，反之越大。一般0.75比较合适==，涉及数学推导。 ### 3. dict实现原理 #### 1. py3.7之前的无序dict 1. ==dict底层维护一张哈希表==，我们可以把哈希表看成一个列表，哈希表中的每一个元素又存储了哈希值（hash）、键（key）、值（value）3个元素 enteies = [ ['--', '--', '--'], [hash, key, value], ['--', '--', '--'], ['--', '--', '--'], [hash, key, value], ] 2. 由上可以见哈希表的存储结构，我们也可以看出，元素之间有一些空元素，我们通过增加一个元素来讲解具体实现。 - 计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（DictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的enteies哈希表中的下标位置 - 若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等 - 如果key相等就表示key已存在，则更新value值 - 如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止。 3. 我们可以看到，==不同的key计算的出的index值是不一样的，在enteies中插入的位置不一样，所以当我们遍历字典的时候，字段的顺序与我们插入的顺序是不相同的。== 4. 我们同样可以发现，enteies表是稀疏的，随着我们插入的值不同，enteies表会越来越稀疏（==enteies也是一个会动态扩展长度的，每一此扩展长度，都会重新计算所有key的hash值==），所以新的字典实现就随之出现。 #### 2. py3.7之后的有序dict 1. ==hash表、加上Indices表(索引表、指数表)来辅助==，其数据结构如下 indices = [None, None, index, None, index, None, index] enteies = [ [hash0, key0, value0], [hash1, key1, value1], [hash2, key2, value2] ] 2. 下面为具体的实现过程： - ==计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（IndicesDictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的indices的下标位置（注：具体算法与Python版本相关，并不一定一样）== - ==得到index后，会找到indices的位置，但是此位置不是存的hash值，而是存的len(enteies)，表示该值在enteies中的位置== - ==然后enteies会插入次元素== - 如果出现hash冲突，则处理方式与老字典处理方式类似 3. ==新字典存储数据本身的enteies并不会稀疏，由indices来维护具体存储的位置，enteies中的数据是和插入的数据是一样的，所以新的字典是有序的==。 4. 这种方法，字典 增删改查的时间复杂度 会有以前的O(1) 变为O(2)，因为多了一步查找的过程。而且字典扩容和缩容时要按照Indices的顺序来保持字典始终有序。 # 九、集合set {} ## 9.1 集合概念 1. ==集合（set）是一个无序的不重复元素序列==。 2. 可以使用==大括号 { } 或者 set()== 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 3. 基本功能包括关系测试和消除重复元素，集合对象==还支持union(联合)，常用于将list中的元素去重== ## 9.2 基本操作 1. S = set('abcde') 2. ==添加元素：S.add(x),若x已存在，不进行任何操作== 3. 添加元素：S.update(x), x可以是多个，用逗号隔开 4. 移除元素：S.remove(x), 若元素不存在，会报错 5. ==移除元素：S.discard(x), 若元素x存在，则移该元素，元素不存在，不会报错== 6. ==S.pop(),随机删除一个元素，若在交互模式下，删除排序后的第一个元素== 6. 包含的操作如下,==交集&，并集|，差集-，对称差集^== a = set('abcde') b = set('abcfg') 交集 & c = a & b {'a','b','c'} 并集| d = a | b {'a','b','c','d','e','f','g'} 差集-, a中有，b中没有的 e = a-b {'d','e'} 对称差集^, 在a中或者b中，但两者中不会同时存在 f = a^b {'d','e','f','g'} 联合unition, 等价于求并集| g = a.unition(b) {'a','b','c','d','e','f','g'} # 十、文件操作及os模块 1. 01 打开并关闭 打开一个文件（若不存在则创建） f = open('file1.txt', 'w') f.close() 02 读文件 f = open(\"./index.cpp\",\"r\") 读取文件中所有数据 contents = f.read() 03 写文件 打开文件 f = open(\"./index.cpp\",\"w\") 1. 写入数据 contents = \"hello world!\" f.write(contents) 关闭文件 f.close() 2. os模块，python用来操作文件或文件夹的 3. 判断文件是否存在os.path.isfile(fileName) # 十一、类和对象 ## 11.1 私有的属性方法 1. 私有的属性，不能通过对象直接访问，但是可以通过方法访问 2. 私有的方法，不能通过对象直接访问 3. 私有的属性、方法，不会被子类继承，也不能被访问； 4. 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用。 ## 11.2 共有的属性方法 5. 继承，__init__()中使用super().__init()方法 5. ==公有类属性，类和实例对象均能访问，类属性只能类修改==；实例对象若修改，则会认为是此实例对象动态添加了一个实例属性，不会影响到类属性。 6. 类外不可访问私有类属性，可以在类内通过方法调用 6. ==实例属性，只能通过实例对象访问== 7. ==类方法，@classmethod, 类和实例对象均能访问== 8. ==实例方法，只能实例对象访问== 9. ==静态方法，@staticmethod,类和实例对象均能调用，只能访问类属性== 10. ==__new(cls,)，在init之前，用于创建类的实例，返回实例化出来的对象，必须有返回值== class Cat(object): def init(self,name): self.name = name self.color = 'yellow' class Bosi(Cat): def __init__(self,name): # 调用父类的__init__方法1(python2) #Cat.__init__(self,name) # 调用父类的__init__方法2 #super(Bosi,self).__init__(name) # 调用父类的__init__方法3 super().__init__(name) def getName(self): return self.name bosi = Bosi('xiaohua') print(bosi.name) print(bosi.color) ## 11.3 super()方法 1. ==super()是用于调用父类（超类）的一个方法== 2. ==Py3：super().xxx== 3. ==Py2: super(Class, self).xxx== class FooParent(object): def init(self): self.parent = 'I\\'m the parent.' print ('Parent') def bar(self,message): print (\"%s from Parent\" % message) class FooChild(FooParent): def init(self): # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象 super(FooChild,self).__init__() print ('Child') def bar(self,message): super(FooChild, self).bar(message) print ('Child bar fuction') print (self.parent) if name == 'main': fooChild = FooChild() fooChild.bar('HelloWorld') 输出 Parent Child HelloWorld from Parent Child bar fuction I'm the parent. ## 11.4 类继承顺序（深度优先、广度优先）(mro方法) 1. Python 类是支持==多继承==的，一个类的方法和属性可能定义在当前类，也可能定义在基类。 2. 针对这种情况，当调用类方法或类属性时，就需要对当前类以及它的基类进行搜索，以==确定方法或属性的位置，而搜索的顺序就称为方法解析顺序==。 3. 方法解析顺序（Method Resolution Order），简称 ==MRO==。 1. ==py2默认经典类，继承了object才是新式类== 2. ==py3默认都是新式类== 3. ==经典类都是深度优先，从左到右，纵向寻找== 4. ==新式类：广度优先: 从左到右，横向继承== 5. ==Class.mro()方法 > 类的继承查找顺序== 6. Python 发展至今，经历了以下 3 种 MRO 算法，分别是： - 从左往右，采用深度优先搜索（DFS）的算法，称为旧式类的 MRO；会引发`菱形继承`问题 - 自 Python 2.2 版本开始，新式类在采用深度优先搜索算法的基础上，对其做了优化；违反了`单调性`原则 - 自 Python 2.3 版本，对新式类采用了 C3 算法。由于 ==Python 3.x 仅支持新式类，所以该版本只使用 `C3 算法`==。该方法有点类似于`图的拓扑排序` class A1: class A2: class B1(A1, A2): pass class B2(A1, A2) pass class C(B1, B2): pass c = C() c.foo() 经典类：按照类的顺序纵向找其方法 C类的foo() > B1类的foo() > A1类的foo() > A2 > B2 新式类：从左到右，横向继承 C > B1 > B2 > A1 >A2 ``` 十二、函数（function）与方法（method）的区别 ==范围： 函数 > 方法== ==函数是python中的一个可调用对象,方法是一种特殊的函数== ==实例方法，在类中未和类绑定，是函数；在实例中，此实例方法与实例绑定，即变成方法。== ==静态方法没有和任何类或实例绑定，所以静态方法是个函数==。 ==装饰器不会改变被装饰函数或方法的类型==。 ==使用type(),判断其是函数还是方法== "},"02-Database/":{"url":"02-Database/","title":"Database","keywords":"","body":"Database Mysql Redis Mongodb "},"02-Database/01-Mysql/":{"url":"02-Database/01-Mysql/","title":"Mysql","keywords":"","body":"Mysql Mysql "},"02-Database/01-Mysql/01-mysql基础.html":{"url":"02-Database/01-Mysql/01-mysql基础.html","title":"mysql基础","keywords":"","body":"[toc] 一、基本命令行操作 1 基本连接操作 1.1 Python操作连接Mysql数据库格式：mysql://账号:密码@地址:端口/库名 mysql://root:mysql@127.0.0.1:3306/zk_test ==Mysql 库名不能带中划线，zk-test不可== 1.2 表增加字段 duty表增加俩字段（不为空，有默认值tf, 加索引） ALTER TABLE duty ADD COLUMN depart_name VARCHAR(64) NOT NULL DEFAULT 'UnKnow'; ALTER TABLE duty ADD INDEX depart_name (depart_name); ALTER TABLE duty ADD COLUMN role_name VARCHAR(64) NOT NULL DEFAULT 'UnKnow'; ALTER TABLE duty ADD INDEX role_name (role_name); desc duty; show index from duty; 1.3 反斜杠\\ 转义问题 ==\\在SQL = 语句和like语句中，分别用2个\\ 和4个\\ 替换，方可生效==。 # SQL库中存在的数据：央视影音事业群\\央视影音开发运营中心 # 实际SQL操作：select * from duty where depart_name = '央视影音事业群\\\\央视影音开发运营中心'; # like语句：select * from duty where depart_name like '%央视影音事业群\\\\\\\\央视影音开发运营中心%'; ==mysql -uroot -p密码 -P端口 -hIP -D数据库名 -》连接数据库== mysql -u root -p mysql 连接数据库 select version(); 查看版本 show databases; 查看所有库 use 库名; 使用数据库 ==select database(); 查看当前使用的库名== create database 数据库名 charset=utf8; 创建数据库 drop database 库名; 删除库 ==show tables; 查看所有表== desc 表名; 查看表结构 create table 表名 (字段介绍); 创建表 alter table 表名 add 列名 类型; 修改表，新增字段 alter table 表名 drop 列名; 删除字段 drop table 表名; 删除1.4 建库、表、插数据 create database db_zk charset=utf8; # 建库db_zk SET NAMES utf8; # 设置编码格式 SET FOREIGN_KEY_CHECKS=0; # 去除外键关系检查(表操作完后记得修改过来) DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `gender` char(1) NOT NULL, `class_id` int(11) NOT NULL, `sname` varchar(32) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_class` (`class_id`), CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`) ) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8; BEGIN; # 插入数据 INSERT INTO `student` VALUES ('1', '男', '1', '理解'), ('2', '女', '1', '钢蛋'); COMMIT; SET FOREIGN_KEY_CHECKS=0; # 改过来外键依赖 # 查询笔记 if(isnull(number),0,ty) # 字段为空时 二、CURD操作 2.1 增加 insert into students(name,hometown,birthday) values('黄蓉','桃花岛','2016-3-2');2.2 修改 update 表名 set 列1=值1,列2=值2... where 条件; ==批量更新数据：update table set 更新字段 = case 依据字段 when 条件 then 更新值 end where 条件；==# 更新duty表：若role:四线值班 》 则role_name:LEVEL4 UPDATE duty SET role_name = CASE role WHEN '四线值班' THEN 'LEVEL4' WHEN '三线值班' THEN 'LEVEL3' WHEN '2.5线值班' THEN 'LEVEL2.5' WHEN '二线值班' THEN 'LEVEL2' WHEN '一线值班' THEN 'LEVEL1' WHEN '页面值班' THEN 'LEVEY' END WHERE role IN ('四线值班','三线值班','2.5线值班','二线值班','一线值班','页面值班') AND duty_time > '2019-01-01'; 2.3 删除 delete from 表名 where 条件 ==完整的select语句==select distinct * from 表名 where .... group by ... having ... order by ... limit start,count 2.4 查询 select * from 表名; 查询所有列 select id,name from 表名; 查询指定列 ==as 别名==的使用 select id as 别名 from 表名; 起别名 ==distinct 消除重复的行== select distinct name from author; ==where 条件查询== select * from students where name != '黄蓉'; select * from students where name like '黄%'; 查询姓黄的学生 ==范围查询 in表示存在的，between ... and ...表示在连续的范围内== select * from students where id in (1,3,8); 查询id是1或3或8的学生 select * from students where id between 3 and 8; 查询id在3~8之间的学生 ==select * from table1 order by id desc limit 10;查询倒数后10条数据== ==select * from clog order by rand() limit 10; 随机获取10条数据==完整的查询 select distinct * from 表名 where .... group by ... having ... order by ... limit start,count 1.1 排序 order by desc 降序；asc 升序，默认升序 select * from students where gender=1 and isdelete=0 order by id desc; 查询未删除男生信息，按学号降序1.2 聚合函数 ==count(*或列名) 统计数量== max(列名) 此列最大值 min(列名) 此列最小值 sum(列名) 此列求和 avg(列名) 求此列平均值 ==聚合函数不可用于where语句中，可用于having语句中==1.3 分组 group by select age as 年龄,count(*) as 数量 from students group by age; 查询各种年龄的人数 ==where==是对from后面指定的表进行数据筛选，属于对原始数据的筛选， ==having是对group by的结果进行筛选== ==【HAVING与WHERE的区别】==： ==where在分组之前过滤数据，where条件中不能包含聚组函数。== ==having在分组后过滤数据，条件中经常包含聚组函数== 1. where 子句的作用：在对查询结果进行分组前，把不符合where条件的行去掉，即在分组之前过滤数据。另外，where条件中不能包含聚组函数。 2. having 子句的作用：筛选满足条件的组，即在分组后过滤数据，条件中经常包含聚组函数，使用 having 条件过滤出特定的组 # 查询：平均成绩大于60分的同学的学号和平均成绩； # 思路：根据学生分组，使用avg获取平均值，通过having对avg进行筛选 select student_id,avg(num) from score group by student_id having avg(num) > 60; 1.4 分页 limit start,count select * from students where gender=1 limit 0,3; 查询前3行男生信息 ==从start索引开始，获取count条数据。== ==start索引从0开始，而id是从1开始的== ==所以，获取第10-12条数据，应该是limit9,3== 例1，假设数据库表student存在13条数据。 代码示例: 语句1：select * from student limit 9,4 语句2：slect * from student limit 4 offset 9 // 语句1和2均返回表student的第10、11、12、13行 //语句2中的4表示返回4行，9表示从表的第十行开始 1.5 连接查询 ==select * from 表1 inner或left或right join 表2 on 表1.列=表2.列== select * from students inner join pythons on students.cls_id = pythons.id; 查询班级表与学生表1.6 自关联 例如省、市、县表，结构类似，且自上到下是一对多，可以定义一张表来存储； ==自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻 辑含义是不一样的，城市信息的pid引用的是省信息的id==定义表areas，结构如下 id atitle pid # 因为省没有所属的省份，所以可以填写为null # 城市所属的省份pid，填写省所对应的编号id 自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻 辑含义是不一样的，城市信息的pid引用的是省信息的id # 查询省的名称为“河南省”的所有城市 select city.* from areas as city inner join areas as province on city.pid=province.id where province.atitle='河南省'; 1.7 子查询 在一个 select 语句中,嵌套了另外一个select 语句, 那么被嵌套的select 语句称之 为子查询语句1.8 模糊查询 ==like== ==%表示任意多个任意字符== ==_表示一个任意字符== select * from students where name like '黄_'; 查询姓黄并且名字是一个字的学生。 二 数据库设计及导出/导入数据 ==遵循三范式== 第一范式：==列的原子性，列不可再拆分== 第二范式：==必须有一个主键，非主属性（列）依赖主键== 第三范式：==非主属性（列）不依赖于其他非主属性== 当一个表中的列太多时，并且某些列不经常出现在结果中，==可以对列中的列进行拆分==，分为两个表，一对一。 ==导出：mysqldump, 导出数据及表结构：mysqldump -u用户名 -p密码 数据库名 > 数据库名.sql== ==只导出表结构：mysqldump -u用户名 -p密码 -d 数据库名 > 数据库名.sql== ==导入数据：mysql -u用户名 -p密码 数据库名 导入导出数据# 导出数据到sql文件 mysqldump -uroot -p密码 数据库名 > sql文件 # 导入数据 mysql -uroot -p密码 -P端口 -hIP -D数据库名 三 主键、外键 ==mysql中处理字符串时，默认第一个字符下标为1== 1 主键 主键（primary key）一列（或一组列），其值能够唯一区分表中的每个行。 ==唯一标识表中每行的这个列（或这组列）称为主键==。 没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行 ==Innodb建议使用与业务无关的自增ID作为主键==2 外键 可以使得两张表关联，保证数据的一致性和实现一些级联操作 防止无效信息的插入，外键约束:对数据的有效性进行验证 在实际开发中,很少会使用到外键约束,会极大的降低表更新的效率3 是否使用外键 外键是否采用看业务应用场景，以及开发成本 互联网行业，用户量大，并发量高，不推荐使用外键，把数据一致性的控制放到事务中 传统行业，人数可控，活跃人数有限，使用外键，降低服务器性能，降低开发成本4 外键的性能问题 数据库需要维护外键的内部管理 外键等于把数据的一致性事务实现，全部交给数据库服务器完成 有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源 外键还会因为需要请求对其他表内部加锁而容易出现死锁情况四、mysql配置文件 mysql命令默认加载的配置文件：==~/.my.cnf、 /etc/mysql/my.cnf、/etc/my.cnf== # /root/.my.cnf [client] host = 192.168.210.68 port = 16030 user = root password = ouFo3bof53J1hqoTvrtnFMp7PP1DwCHM0hVGFjW1 五、SQL连接(JOIN)查询 1. 概述 SQL join 用于把来自两个或多个表的==行结合起来==，基于这些表之间的共同字段。 展示LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。 INNER JOIN（内连接，或等值连接）：获取两个表中字段匹配关系的记录 LEFT JOIN（左连接）：获取左表中的所有记录，右表中没有的为None RIGHT JOIN（右连接）：获取右表中的所有记录，左表中没有的为None FULL JOIN：关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行. "},"02-Database/01-Mysql/02-mysql45讲.html":{"url":"02-Database/01-Mysql/02-mysql45讲.html","title":"mysql45讲","keywords":"","body":""},"03-Algorithm/":{"url":"03-Algorithm/","title":"Algorithm","keywords":"","body":"Algorithm Data structure and algorithm "},"04-WebFramework/":{"url":"04-WebFramework/","title":"WebFramework","keywords":"","body":"Python Web Framework Django Flask Tornado "},"05-Git/":{"url":"05-Git/","title":"Git","keywords":"","body":"Git Git "},"06-Linux/":{"url":"06-Linux/","title":"Linux","keywords":"","body":"Linux Unix Os Linux Mac os "},"06-Linux/01-linux/":{"url":"06-Linux/01-linux/","title":"linux","keywords":"","body":"Linux Linux linux 发行版：centos\\redhat\\ubuntu\\ "},"06-Linux/02-mac_os/":{"url":"06-Linux/02-mac_os/","title":"mac_os","keywords":"","body":"Unix Mac os mac m1 版本 "},"07-Docker/":{"url":"07-Docker/","title":"Docker","keywords":"","body":"Docker Docker "},"08-Computer/":{"url":"08-Computer/","title":"Computer","keywords":"","body":"Computer Computer Basic Knowledge "},"09-Network/":{"url":"09-Network/","title":"Network","keywords":"","body":"Network Network TCP/IP HTTP and so on "},"10-Tools/":{"url":"10-Tools/","title":"Tools","keywords":"","body":"Tools Tools Ansible Nginx Rabbitmq gRPC etcd "}}